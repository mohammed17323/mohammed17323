<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8f770e652698a0864666d4839e2f22db17da7273a3c7447ea7a858fa7b08fc8e35131cf20b088dcb37121ab1ab013b0fa194a708a48755053e978c4e01c75e6a637933171e53dfc3ebaaf6166a08adde9b0070cbba0aa06ebeffd3615a5265921ed2754716bb505df29d143cb28781945bdc45f78e53a8adf8e9f6528a1f1b723fd6623eaa415cda78c0a201241c8e3be9d32756427640c2caa0c8b327b0158bc47f2de5a10b1475947441d1082279d31d69d9066f22a8ddccbcf5e088163615490a2dd26e571af30d0a3cc002d11c09980a97e48392d997c89acd5e0bea2afcaba74e26f030c382aa83672f9eff6d18b5329a15457752f9faf012f49a1813527430c27303e5a60c30917452dcb81e760cffa5618ed63ebb45668b54af385cc1a98b6634e0ea5631602d80b1aa916428f07d9e199e4e724443153de5f22f394a38609f987df8631438581d61207cc51f3ec17b5f71dd81e180a4f5dbe983770173ee3b8b1006a7e3f2f5234f64173a10fbe84cc99492b111145b61621775520b7ac183780eae7aa69cd394dccec44aa5e40a95477f75ef61f1604bc726ba4ea3c15267870c40d9b349e8d40ee4f8b17c9b82cf2f99ed03cb3ae795f36da623e6beb92fd5f46157a95efede37afd205c780446bd4eaac2938aa1d0b561b38b7b8e005869de0d53810637e70e1960bec429b50c6456a96f317a822e28f0ea4c34c1b93ef761d377eaf8e25e54879e95bc922a5f4cb9a3263b73fd1caa79b23842eda65a3197d563c21f2a441655f21f037bdeb471199f91649104869694492440e1443f0bf927813a9974238789f073be25c696c9c7f75e4c433d060e8de309d10740f991868fd783a102722fcb3530b2397359b6f8f3b6ad06dea4a55cd0ef54966ddc8ef3d67fc3ca452b3d81f14d138430886c767a20a03603822bc3af2e9938d3018b756fc3baec4df54d5182a40d14de30db2bd0076529d60a774c85102d8e7018750d842a204dce89c9a33caa1b23d5616688226be3acb71764490f4078d913ecf008f4b0386e19f4237dff4e626aacabb3be4ef38f8d6026b76652d1b153b38b2d6ac5e70d35a89b90b703ac94d174821250c7af1b54504c94f46472d7d87ea00ce8632c988a132d5dc230e95a18fe5f6f889b53da14af049c3b4f55a1bc50092d1f4d1c4e991792afaac54d1857160bef733064bc6448983ae18a44a1f27d5e19e224bf160260ee3bb7d91b387029c97b4e545e0dcf8b38382b2157da9c3b2556543aaec7fd61c653b7354c3c27576778677d5ffa7172e5f2eb1c1457df19fc7c4a103a6f3a31a0b84bf99c4c1045caf29e6994928e54f60cd1b754fe6bac8ed53ea0d17f30698ee10d8355a86c41f9425d12822e4b14138232e6c8bd0eb29507a5b9751bdd278d5b79cd7e9cdc797e99edb931f35be065fe16dc2de9abad4b44b6180846e0996672d1b03f759e2dcaafd65af4f3c43a2ee8031b1b5172def16cc4027459117cf51d896fe372b2f7a333458dc21df2a5c21ca28f4e487cf3b29983283ef462b5a4ad508998fa6388ff1e8a15dbb686e04adbfe03b60b3bff1703207b1a216355a6d262a8afa99ebbf560dcd3688d3ea5360cfdf314b2af9865ec07c473173d5d6fedfd3af403f7cb9f2a25f52fce534635f505b6ef34c7cf052419d031f9222aa29dd829127e30bc3a7aedfdb8d855c4ed376e86f5b209c3819407588ffae5d083721e25f69ec4f2269e93307c8b745e8b2927046694b6c44952598237c85d10dd261455718ee5f43240ba72a052c92ee649dc39249c9395420af50c50d406679780b054745e056ed479ef3a49009325921f535b372f170083af7927e87170e99f2958d38f4e55609cd4125f6aac70a2907f869982dac5d78c455cc5fdc6444b9bc24ed5fdf7e3d12b79f55c4b9ccc3e2fc40857f8338a181c538c3c7dc6745fbe4ec6d4e281eef5861cbbf492d5a001d7766625383b7a7e176a1744be2c1fa597e8c78a22506a3b15e9bc01ff7bbf2c8cfc51c700475773720b5c1f2ed0ddbc5760190e5601331a59e8342ff875b944809682057ed7138369616dd5236109429194764894b545f15cee6f62e132c7dd1ee03b021c5b3492fd8f691c6909509085fd8e7bc267b24e2ba80ef8959159f81179ddfcaa56378a896673a9737e389e5c81e6c09e0c9be936d3db78105ae9a13bc3c342a0c9ea6965eb7171263dbb38a8a44282b3b93c16a74b315a04510b9afed4919ef81652e2931bbb3fe35c16506c76d7758fe8b781dbf5f4ec9bb6fae55095b932d90679f440fa5fe501f0391f5760384f141cba343d12db460b8fd9f7b3f7fb3eb94ffd06dcfb86734464cf4b7ec7a07c57361fee467c057fc83dafe9753e741fd54c319ec1432d4ad944b131569dc81b1885d1f72b510972336a9046cfc52826ca374f65bc75e578eb7e425bc526936c6da30051ee27bc16ec6af2a46bc03dd6bbbae158fa55fdf2ad66e43a9e583b21654ad7891c7958287a573eafc2dd2311ad1c39e7585154ab7138a36db661e8a5a774aeecd2eb5ec55bb2ce8656d8a486aefc436a7845cfa3a3762fb5870950fbfa93542b39d8bc204d59cd6cb3c89d225e8b0dc04fbe93dcd60d5edc0474b8ad94e63517114e695040a488ada212338b4665bdf69da89cb3efbc06c6d5e586ed0ca8786bc9099c4c40175e001b1b17bbd6a8049924fe6bdaf31383c035d8aacc4d7c63616185839f4cfea9f5af5565214953db824b1cdd86034e48b409617aafea3a00ee0166e01796ec6b2d389990bc5748179fbd9b188994cae7b8cfd9adaf457bcfbaf1c352df85a703fb345159f1338f2fa6aa71faa2a363dfc9d93c8e189eb8ae4282b762a097120a11670023527bf6be294aeae5daa7e76ad79aeeb2a67e8489e49aa91c072791aa2979372f6b93c05c000a9b03ade169109476df5e0dcbde4acdf28a4e8aa48f813970d3cbc31c5f4f58eeee8dd37438e1b7aee73e8e6355f1acef6d4c850244d51e1042029ab9b4e5f7217aaf0285e00bfdcce2bc6ecb5d635101883c7f403c38487814d60312beedf6587f9ce9d9faaccc7d71aaa98f9c99b5cd4fae4e828b5cc9ff22b7a1c4b44da85fa6ddac5ad48d07da69dc02db63781527c5169fa65e1104abc49d0a5c84cdb68710e4ad3f77bb7e96dadea64f9f126346360683729ae36a874e70ee17315881b13b1e0346a76308221308e882f4812f1a161364986d3db287d79c390181051fcd6602a52e90adbb17baa06faac1fc722f5a91611259ea3f8279236829744d0d33304fde6654437867e42d13f317f7df034ef15eecd6c9933f79a4c8c0b1880f9ebea4dfeb20527b83b3fba1ea47a2f0b8aaa5913ead53cc24fd69e1370e47978d8ab070465f1e15ce0d90e213d300a45f831c3fe6acf2efdb90829b4cf3ceed5a4e84c188eb9dcc61d3e457365317a5c29523c37ce168777f137c7ea529e745fc42d6a0621fcab55d53ca56eff4fc283b53444355acfea56302e6abe3ed430656df54dd46bd9705c30c00ecbead370f9250b90a34762316c162f7d09413fe17af5fee776a7327a6cdef28ab7f36af0988b62ad4d9a2b88b65a275831ece667024b65e2399588873410eef0867db38f1bcdb3e6dd074d8578c45e08afce47f656a67ebb78f2cffacac93b1ad4b60622e73b145a4989da2d5204a4c06d7bcf936d2ab206e33cb8778532359d3b8c4177ac994504b929f1ef00094fa87875f55e60a5c39e85e8d293015ed712d08b4e0efe8dd9ce5e9470ef62f0004fd06de48f8df79588d943624ea82f09373c35c962d213fd67c1f07f780859903bef56f74ae4d4b8b3c4b381bfa07eba30e59e1bca6da8550dd55295fd3c076997ca3a924dd1fbab00ffb86a455a9211b5c119208ed07d97228a2274b28c364d03d822304df006bd2dd5b071b9b42c4e995ee4341eae629cf0c8c73a48a8512e7040fd67ac09abe9e2b3d1aada79126514045998f85836a2cb6bfe531e733bf81ba19820911cd9a14667df3f60f7f76f645af9cd0ef004202c68d18677c56c205249e9a13d8f8a47cc658abb82487d8ff49f867483ed4716896a1c881d291314144b14827a9d533fad823098891bb3ad03a7b9ef28bcf10f068e350e725a3b7780506d8b1de30df38cf034c02c7109a08cbf5f59946fdc344634c82df97b27196c44972e7dd544f9f1ee213bb6b7bfc2cf981d755236f919a6b8fafd8adaecb02cdad2c6e463c89f79f789980962450191449214bb98a44f9675c1ac2df94b567c17c8dd4e9c5d903191f7ea199b179f5c2ee3cc89e7fb5421bab3f1ee51849b9ea412171ccb8e3715ea79876bbcdc9f408425be3ac45846b8fc6b02be287734afcc97749ae95e65027e7d5976dfaa6c902ee5039d8c7f779d8138b0acce2d0e26c46d15c1fec20a9e01192ca5b53e426f95eb3fd53ba35d91d38c80c98151d97c9e24a1ddc93980d0c14439780373a66b0cba3eb8a8d6696051db4813accad3578adc1cc32da4f5c8349f17219f494257b8aabbd1d9fc5e46c5c080d2796094e71b64a75ae1e69d0f0fe07dba3b2b3b8e1b6bd9646dbff47271defaa514aed9e5206c9e3ae455246a7ca8a9f32ab3ceba763ca144c380350cd2a751a1da04bb1e4038f5ecb5a77aa43807320a090549920fb7bb79f5c94e3b055680f4c654e561768e3bd1d83df6e37e50791aa2dec7b72c2eba7135d5e1f32ec7bc050ea9a9e27b76de178da85ce9008e25b1962a38c2b41d5c2f3b7d53e27b74676c7259d78645dfe971c916d77d499895d46656fd4a2a4754cc088b488629384cb10b252330cc4f5190bef35a15c64aa4d6dda28fdb646cd22a1a60f22c4cfccc8ba894376e6d9d367e8e4e4bc34cc34c75e922a36c0cdc65051e4e91aa97d5003265d701ec6e9b6a72ab23458b1322cc3bed89466af8ee49aeb1bf112c0cb8b9e4dc5076ac0eb3de5f191abe3451b17df8c5b58e8170c8ba81a32ff8a58d816634bec153ba15853ed2d7601e9a4ed6eca0ba20edf94763c55fce70d15b6230094ba44738581d00ac01b6547b7efbd783fa491433dd87c43dfc1e4698ed8cc5e05a5172c99bda039b3aa71f2605a446be73fc17193c2f58a9b231d8307f02bc339f0ccc938c8ca7e41b22b089b820d2301a441c4ce81cd0f0471e67f1976e637616975f89a448e32eea07181e11b7ac83842340fa4054c2b03b6d6c259f661d7a161f1651eb1ee5118f9b832172c22b943a7d2566889a67dd186a50143e28035fc230c13283213d316c243a9e07228ff0ac5bbe8a22a0400c7ca9c6e655a0b210de06a43c37a6c491578692f284c938a4d6ed073bf8f6a0a6aff3c3d79777b9320e7356751aab9cdb3fc1700e1723251d63d0eafe6024f15b685906acd739b12a84cf657260534df0f1db66cc725b8bbefa021d98630487ab0d1cc4144c9591270232d1b0d35af6546bd87cc998087626011b94d8226059930dde0d873b1a25de31ff499b96b9dd6acd530712d64d68c8392168b0d7555e360b15a984e3192bf9a17e8ac876e88ef2193138370b3c26ad8eddd2de1a0d4c6bb47b34fd84013fd2f5e540582fd498fc2795cd1b1a47c434febe4e27d0c21b2db1bd15ce21d23aea18b7eff335a4202571fd29f69b5696f8775bd7f44a724d8f33f834418189dc8531b8fab1d531af8dbb5be00160002daf4d6188e21004092576de374f30f40e7190e05bb9577e86147c68aff487a28cedfa1dd3ecc497ad12173673cca3bd08a3f186ddc6387398cbdda314a935538c85d0e6993c1c3b78b3fb74caed400344f8704862b01f5954f7297732579a52fecd63553e5cab86b6837c3f2f8762bceb79947f259553e99d32cc8553aa71d9f4380d550e5ecd473801563220f44738bcee375be5a1557436a4ffbd94bd05d86af8b57a15eb3c89258de433a1def8078eef3d79f2669dc0225960b12b04535f25092319476354a13a51c7fc48618898695b7a98a82c9cdfbf4659a8ac43c0795efe2345d680aa1d56e3108f322daaf399f1d1e74c9889edf81db713214e45ea13bb1ca2a0e85bedce666cf9132092782c08dc1be91eee16fb4ee5d8a4e391c555fe8ac5945522a79cecd1349071868f43163388c8907c61decb8db4924689dd72e3565cbb218b48f2040411828044c65302ba81c28323e129f312079d0c2bed29d3dcff0ffcee243493bbaede869dada0bbf36d0b2b064d73918ce46cf9f0c768d3c06d5216613e3ffcf45d609ba36bac58cd54158110839d44dc94f337f85a29a2b1fa12c2c192e3a83dbec3d6ff893cab6b9809e44196740823d8b5a9b68f81ed1ca602d7937a9c067380a70c197b6560bb7938210363114a9bee7c0597a74f0d31d07fbf97c617dfbd19f40e3ec4aad763f24aec2c835412124d766772dd7a92fad6401126e56530d6d93601d8e6e9db95dc4f235aa7bf10225b2238f63655d9c769cc3b26695e821a6946a82a4f0650ba298a25de069295680fd48bb28677bc17d5ed5877d6f552014b02f3dd4c5e0d216f6ed211b8fc8b2e2e45154c0baa235556cf92e1b49affad1a9169c82129058d9e124d0c5035e2719fb4acbd54e93b5eef7f3143344144e55efcc1b9e2c1d193054ea3daf3881c43e98c2ae7424557a4b36729cb7d7427ae1dabf7da0f015d16d41a065d814deb3f2df932a48ed3c206f6ad198a358e141272283ad9dc6667f4baa52e11d58cc730d20821a9fc12e6a7565bded8f141a4776b14c30d77a7f8e257ebbf8a95d22cf08b4864edd3537eb5d93a0e5333acea10c66efbac9178a561a009fbf23fed011556a230d2549df38927cd5771d2bcb44388fb36007e7837044537bf544043a76e385175c3f1f14af75857dc24d92cfa4cd6ef036e77d7f0c10c4eae6172b19e6b474fafb80992c42f7ab19b66a542c11e5f1796f053af83d10e4f84fdb996b0686d8ec2b672ffc41a4b9b18b4a34f3557fd214feec627e16a8f138d412b2cd98ca1cf2ba26525a7e9ae85511816983ecd70c6c3df91bed3583c0a183de7f1c142df3d3a1aed091fe0b90718c0f8206b36393a58003c0b1854b0d262f6952364a543e45448f6403daee5ef13576f0be1c16ba8713f1f4d3f58ca9203fb7b2bac0306fa82c50af3487110f24e339583654386512ec4c603ca227bf814dc3d20c842ed683d7aa56da764ef822ecad516994d3d60ce5fc7b442b67754da6fe255c5a1e9f073ce6cb6f531278d48f6373926955594c9f06911c4be717a8d6a7c0d59931fe2dc5b53c31d7e11f8fd38cbb860e18cce26eb0f975ed0167c712d88a8170a701c89cc0af4dda869649f497dbed8664767c993976a1008d0c3d9b51c7b4705f5605ac01bc59353d7fa0a77fd19c66f9c8f2e87cd628ebeab83e30205558dec18a9c25e8a40aca0b1e08cccb6d3674afac67f0551236c78e53062213c5f28a1f394bc980db197c4ea83e82aa989c2e205a47e556f2f2f6c109e62dc8cc7c665c94ad8ef0837399f0438715ff670f243938264aea68d605a089814825e83168e8762a5c8ccede22b003aa02de94817fad007e6211b89acc66e88cbbb69f7cfbdf745029b3f781916fccfdcb42744ac382829abb9e12d3b84e1b067cd743fb4178d70215ce7489992bbaa49f9c6bcbf4ed34105bdc81dedeaadfe8ec9f512aa90f0aa232148cbddb3a404f8b5672ccede090c160b3440f2d4c2ddef206012c05c8b260f809a39331a48d3bcd8d652b7f5744005d553b7a9aa57a18c24fe8cf8c409614195faab868eb35cd0a5cf061c83fba987103011de6867816734a720b0a5cb91712d5d6dbd1e30746a8d46f2363bafaca28199e65d9f169df1fcb41100cc54f2fc715f9c53bb295ac42f50d4e45851d0c0a98675ef39f24abcb3f7f37b3d0bec02c449d0ad2b368f76d517afd38ede6967b94a1fe337e9efd856484f8344f02c9b3b899a4a0f764f0735e237be811a21015c45aad7e3843bef6b4ee3c1025c665090a96f7d6372cac8a6e1729331e7c605f36397b3550c835c33799f545ca9ab7ec46024c0584e28a69c8756d642eff9736c686a1bec50d1fc5044764d7fa78f07ac362f6364e0e44ccf602a096cad390f6441c8821b78f749f1e7148e39e6157c9d407a3e575dc86fa1605f65c6a1697d795ddfcd38d10fc87b7528a685d6d4cf41b397c00cf8deac51a1afe7f26ea8e14476fecbabd2345c4339eef76339400d070634b141bf26ededdff00f516853d15eeb4581bdccbbdadb5a692b39cc849534d7d2bab59677c5cf72cf7e5886d324c1d398f6578da531399c46094059c7f82056e3999ceb3a1e9aef434a2b218007e3012c6b39577eb9f5fada584fa8680cd808ee4f64a8b7000426b51435f9bc0b4a1a7a5a716eb4e47aff30abc8edd3d1ce8016c10b09b1b7f501c8c166fe7227244b6b3478a2c5958e2732422310427408d1fc0c982b400c77238430b80aaa4aaf8be8c161670f453bc3b97af13a3cccf7a26d05fa51c5e1b619b3d50ba4ab9ab68cc57fc2b13acb57ac49ec866492f306982376db6b90867b9664f7d1f1f332fcd6258369ef447ab10a8188cd6126d4795787aa4e701224bef8eafc5737192eb130fc2bf7714511aed0287eedda9e86efebcd80126d8db42c7e8beb7cc7f0362d9a9fa9cb1a92c94f66a80e47a395196943f5b915f3fc29891c84a26ded119a675564f6942a5462f1dcbf5d945908f1cd361efc827c97c08a0096d34bf24f72ad776857127da90dbee05d7c5d1d2124d7d7891f8b7ba143f3d3a36989828adf75ed3a09bbe42199685949580641444c712427a74d3c8f527526d0a5256aa52ede9cba8d1a5c86f3847bbb44df17b229265c4857f0bf02a20c936d7c82c1a0a4cf06701c8ea495c3b758d94371c88907fed1417fda17e1f1dbcca888b09622d625defcd53d5d296e2a56cebd8d8e3601e39d64a52f01119cb44d01c4a706066c3f962a35c9cc56e959ee08cc343eb8f3efd3a61be6de8da2f91a140cb63cdaac06a4d1992ceb2280f89082cd7a4e21cb157aff729ee67c7c6ce6d3b22c25c693cb7d6068b1003d93bf57ec0707db1a725713c57fcc3383199ff44f5ef02a226d2c99e2fa9c49dc0916abeb5f16cfba843df905280650ea43e6fd9d81ada180f59f3b696ae0817268668915199f7a4716ff2d518de12411dfc5540c6d74f2c703bab8144b8b6bf5702f0239f25a233761941e5eec390c7b869d6370f6056735a0195d0ed182f46f9e8d451dc2deca29e83d01faa55fc00a1b73688a40ab99a35ab3439de82287305deac48511dc365380f7d04d33fc37fc5e2f7e10b3daa8959e979f0b0737fe25680bbcdfad469ece49ebaaf0b75acb51a7de23c589d690881ef902814d40861ef45382ecd98632a452a7d2166f98e240fc208c3e913e626090cb3a9e85915b70925cb8b04897e61af26a58c17158e978b70842722f17595cd647392f0277ca8236b2b2069491b09c1f92c1e4635df12f2aea8e2720c917cda2ca77ec770f68afa126aa3ab280e6541d71d76a34271c9e3e8344728c5fa525c862cb5a1c549a718480e3a060f1e86180360dce1f13221e733c38e276e9de89a8bf6d73ae6be73dddfc007bbdea9e382aaa4afa4d9644e130b7bede93324d5332570be8302053d6bb231c1369c844efa8ec72e5938370b3fea09895c2f49cd4f70e1e074556d23f05f776a98613c188fd4ae92c604f163e9853d0b3fc0e777b3450e77754c60c399755fd57576d7802cba1796e9efe10e62b7b1aa5bf452b42b2746a794ea74d69226398f8f19c2dfb2389dce8adcdcf90516d0329cd165473339dc62a00744da79f69564225087bd3f9ab423f90736dc62e3cb89ea6874790f7af5310659011c7e63141a365140f1585d0304ccdd7268d539bbbf78bf76424bc98f27161162ea1e5472d477ea66ba99f9bf606fa1fd7d832dc7eb5de3d4cb2840e61ed5573bbb115e7285ed1fe8892a9fc25d9cfeb82d0b19b37c091591ab2fb75b735173db5dc947f40cac7cf3341f14b473d5880888ad18b06586b101570ab86f952c31ea88c80a905b2093bfbb8d4b27f4d831ccdcddee9988b74967c23e15eb22e907f311f2bc635efab3a721a933bd0aa1abd08393abf0b5b82fceaf836be641d168c941ee833ca6ecc79d7c6898374e4cd3c53777f1c7b3568fe758b8952b369ba92d3aa88dd08f7491a15661f5d96d4c65e23e6e6461f33fbadbb8ec19c0a760dcbc4a1aee595c2f948bfb9e3e28c3efc72adffec105b29f7d6c92f41cf7e037b0e37d8c1f8cfb226d69385976ab75ae25e184155a2306d5e4428dcd44627637982df602bf43f296058c44dc34da0e5c9ae1d27aab6b9603840921cf6d1b3f92b0de44c221e1fcf08d8b7a66247c387181955e33df220f87723c362ce4899dc172ccc53499e2b6d98a2775551a0ddae1ca6112e9080745b12c4c67fe7a5fc7b3b3220040389d429d62cc1e11d8a7bade41885d1d202c6bfc5ed0a3feab7666301d9590e544a6491b50067a75fbfb0c163c8ec73caaa891a7ec62a46f7803ecc27a73f42b91dfc5b6bf49f9295cbc757f5f02a30b5bfe6f308b2c1e623dbb2e722bc540def2131d341b24c71196fb8579c7106435015e719c98694a88195e2a8b4c04ce9ceb168aaacd446b11982bccf9bd27c78f3500e551136af0393159c9e48a11009bb38f3b7067ec1975fab23cdb075a55a8b7d8a8506433a4cf3e2e3b9d06bb213195f031dbad0b1f794b43116a1b67aec3f7910ddb86472ae23020392eb0ea636b6f880a5ceebcb7ab735cadb027cb517b3a63e4f4e20c3b008db928c84724946deeb61bca89feba1a081ba7d0e21c9122b3150eba3050c8284bcf8649ad41fda0ba92e118b941fbc913d7f9a9c5e3623baea3cb67c4990323c48e7313bb4b5c1351b7c3713d8837694d3190d35a8f8ad5a1f4c513def6aabd269f5f17b7070ad7478d1b4e902042c23130d6ad7215945b3e4afcfec9b48985cd31ed11fde8a586838960a249824ba0f9923048b381e57eacf4fb17a4abda68589ce72c6e0bc0c4ab2d4d8188753164035f0d431560a2cbbc77699c6755ca741ef2cee27d3fbb87fe5055927e7c46c36bf38b2c4abe19c3b3bc12adc082a9913898b97dcd67b6e768bc00721eb1ea685e18451a71a49d7791519f5781cf21a6ca520f4ff895bac98a546a5ca43ccdfd0d75110ed24cfe17b3303082d674d6ce6008ed2f3e8bdc7b5a0301e1c2ac131fabf302a8e561367e18dd12e037a7720d66a9ad0a3bcf7500059a93372dd0f7fd968c01633dfe7b43148f3e061cfcf93deba6e3426630402f9fc7e9f41f161eaafaff309146ff63a1949779386ccddbc816dec2671c9927573e6adb6499aa343672facc5d4adafad15e8404ead0c97bd10ad8a09fbb0cfeda95e7f83216b173220d9c18149a0d9207513519a7450416bd448fca54db4db9a4f0fe74b4933e04c9ec97332536e058c0a87f87c640e2453f0355e15c1bee53ac03cb2765ba0a716a81a45d884b7378337215c035c6b23a5586978c2418d8095a0b64c70a07e2cb217c18e714816df981d141b627d8206bcb275b520425ef0774dc2ae177356f4614bf48cf5fd934f6cd08bea22856f103abaa25e5334cd6cfba84dc1bb640d0ab5e21c12c7e49c28bc2a54ce99cf4d2581521b28d3a8eecf5ded11ec0d14136fff9b1ef7e2c52cb6abe71884c5d16f0eb025709b6affb45e351bddb44dea505e216b9f1eb2a4b948c3f8b5ed7085afc24bb2e7f4388bc947352afe9868fb22230d0ebb6c9f1cec5befd6c7c2efe8366cc81d54a5c5a33546acb341ec1517c15fed642b6d7343f963e1d876ece34e86b8de939364a43994d979da492ef1edcbe8bff7431db163f3603cfcff0dcbd45b99665ea4f2852a02b639a1ba17447c74f896adf8138b4d31e8be6c8a9bf838d45b7fc96a073758368dac2f965d904184eeb5eeb1875817866cebec4a9e1102c65e9256b9aa4e22c2f92c8163e28d36f2b0c2dea7e002106e39b9e18354053d4beffb98709868df9faf5750bd67de2a08fc4897904f624eb768181dd73dea16ae2c04ebbe982701bb7a8e2792a3f6a489cae7aebf3d85160d5cd9c476df48f4972541beaba768d0d37a75822cf1b0cb05eeccb69d2a005d919c9b48c289024d2f9f210ac9b4fc7897f7ec85f96f406986c7a4c2be7e126e2dd40f717b471c44240f26d6913d53a90e08600dcd63a55a6965eee6bef9d966455c41b1de95c9e07c48d228833686e557fb654af82fd1a36497eb3bcc1950d44c98485872ec417c9757674e22e2152e8ed392d9c73c8b4ddb15959f7de01029586eb81344bde1de1340ee6c9401b0c1392a958e9cc19cce4105bb44303377eb8abbf7ca849296bb5ae05147e74689f26518bd565a822ec9e813b9896a9b135c37e1f0e1cd6f551fe9ce0ef3f667a54fe7e53e0884fc018a5ae87c3c60432f60032996466a444f8be0772f257d1bf95c31abde47ee4381ff9be04459ee41113925264783bdfd69c3c02061b01e65d8ab2e779c8bfe61d8e085c7f82e30b5be2ef53bb71aa9d7b90fc8213c950924ed57a13448ddb0cbcbbf73a64dc93d3ab43d09f8eefc4e38ecd81f8911eb3090633a3fc4501e2801ad4d73f816c0d759be3ca3dbe0184190fff2fbc42857c577a743dddf5ecce3afc6e266aa425e51dad82440969a097685f741d1410c6de03dd2d376a6de061032bbab7f5652a475af38e498b0b4c7ada0fbc927573a2803b593872ec3f20f1eaac7aef5ea670ce4948ec8f2c4029315a0d37bb47b2f28dc8b1bb65b4215276d33e780ec103f3f799d4ad6c4b4b634eae9663f73fcaf3feb5f0fcc31ada7c0f4e309a27afd5b82be8af9fca14e653594613e03117544302407fa22efc58a595c82480f1f1800d802380a5797c4d30007da53a2c467669373cbae67f343616d9db11d9ab8da519aa81ff5eadb1d08bc97edab200ad7dce7a9fd0146e3b40ded01e6543fee121f5ec1bdfe0ed044fe91f91974b2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"16c1c9fc86f323b51f291b37d0426f2a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
